<!DOCTYPE html>
<html>
<head>
    <title>Prusto Watch #1: First Steps into Arm and the Embedded-Rust Ecosystem</title>
    <link rel="stylesheet" href="http://byronwasti.com//css/main.css">
</head>

<body>
    <div class="nav">
        <div class="nav-inner">
            <a href="http://byronwasti.com/">Home</a>
            <a href="http://byronwasti.com//project">Projects</a>
            <a href="http://byronwasti.com//post">Posts</a>
            <a href="https://github.com/byronwasti">Github</a>
            <a href="http://byronwasti.com//Resume.pdf">Resume</a>
        </div>
    <hr/>
    </div>


<div class="container">
    <h1>Prusto Watch #1: First Steps into Arm and the Embedded-Rust Ecosystem</h1>
    <p> February 2018</p>
</div>


<p>In this post I will describe my initial dive into Arm development using Rust. There are potentially many mistakes in my understanding, so this post should not be used as a reference for how to do embedded development in Rust. However, I think it is useful to describe the learning process being new to Rust and Arm development so that those more experienced can see the pain-points of getting started.</p>

<h2 id="firmware-tools">Firmware Tools</h2>

<p>To get started with writing firmware with Rust, I had to gather a few tools and resources. My build system follows japaric&rsquo;s system, which he writes about <a href="http://blog.japaric.io/quickstart/">here</a>. It was fairly straightforward to get set-up, so I won&rsquo;t repeat what he talks about here.</p>

<p>One nice aspect about the tools required for writing firmware in Rust is that they are all open source and all CLI tools. This means that it is easy write a script to pipe them together and modify the work-flow for how you want to work.</p>

<p>The general work-flow I took was running <code>openocd</code> in the background, compiling with <code>xargo</code> and flashing + debugging with <code>arm-none-eabi-gdb</code>. Technically you can combine the last two steps by running <code>xargo run</code>, which will call <code>gdb</code> automatically.</p>

<h2 id="programming-for-arm">Programming for Arm</h2>

<p>One of the major things I learned this week was developing on Arm MCUs. I come from a background of AVR, so the world of Arm was slightly mysterious. However, after diving into a few datasheets and reading various blog posts online I have mostly demystified them.</p>

<p>The biggest difference I found between AVR and Arm is that for Arm you have to manually turn-on various peripherals, such as a GPIO-pin group. This is done in the set of registers under the <em>Reset and Clock Control</em> (RCC) group. At first, this was extremely confusing, since the name of RCC is not at all descriptive of this functionality.</p>

<p>The second main difference I found was that GPIO pins had to be set for a specific alternative function. It was not enough to know that a GPIO pin <em>could</em> operate SPI1, you have to manually set that GPIO pin to the correct alternate function first. Thankfully, a lot of the work that is being done in the Rust ecosystem is ensuring that you correctly set up GPIO pins for various peripherals at <em>compile-time</em>.</p>

<p>An extremely frustrating aspect of setting up GPIO pins to their alternate functionality is that the alternate function number for each GPIO pin is <em>not</em> in the 1141 page reference manual. They are only in the short, 148 page datasheet. This is absolutely ridiculous, and took far too long to figure out.</p>

<h2 id="embedded-rust-ecosystem">Embedded Rust Ecosystem</h2>

<p>The embedded ecosystem for Rust is quite young, and there really isn&rsquo;t much out there. However, what is there seems to be very well thought-out and (mostly) functional.</p>

<h3 id="svd2rust">svd2rust</h3>

<p>Perhaps the nicest tool available is the <code>svd2rust</code> program. This is a tool that takes in an <code>svd</code> file, which is an xml file and the standardized way for describing the peripherals of an Arm device and their registers, and converts it into a Rust library. It isn&rsquo;t perfect, and there seems to be some &ldquo;fixing&rdquo; of the <code>svd</code> files required before the Rust library is full-featured. However, once the library is created, you can manipulate registers in an extremely readable manner.</p>

<p>For example, the following code sets up pin PE9 as an output pin:</p>

<pre><code>let dp = stm32f30x::Peripherals::take().unwrap();
dp.GPIOA.moder.modify(|_, w| w.moder9().output());
</code></pre>

<p>Although the modify routine on a register takes a closure, the compiled code, according to japaric&rsquo;s tests, is just as fast as modifying the registers by bit-shifting. This is awesome, since the code is significantly more readable than setting registers using bit masks.</p>

<p>The other nice aspect of the generated Rust library is that it allows us to use Rust to its <em>full</em> power. Each register is a normal Rust variable and the ownership model applies. This means Rust will catch, at <em>compile-time</em>, unsafe memory patterns and race-conditions. Essentially you have all the guarantees that Rust provides when doing direct register manipulation, which is pretty awesome.</p>

<h3 id="real-time-for-the-masses-rtfm">Real Time For the Masses (RTFM)</h3>

<p>While <code>svd2rust</code> provides a Rusty library for working with registers, RTFM provides a <em>beautiful</em> framework for working with interrupts. Japaric talks extensively about RTFM and the power it provides on his blog, and I recommend reading the posts in order from version 0.1 to fully understand it. (<a href="http://blog.japaric.io/fearless-concurrency/">v0.1</a>, <a href="http://blog.japaric.io/rtfm-v2/">v0.2</a>, and <a href="http://blog.japaric.io/rtfm-v3/">v0.3</a>)</p>

<p>Working with RTFM is a walk-in-the-park, and the power it provides is amazing. For example, it provides <em>compile-time</em> verification that pins are not being used for multiple functionalities at once, registers can be <em>frozen</em> and guaranteed that their values cannot be changed elsewhere in firmware, and if two interrupts use the same peripherals it ensures that they cannot preempt one another and cause race-conditions.</p>

<p>By using RTFM it becomes extremely simple to write firmware in an extremely safe and robust manner, while also maintaining readability. It is definitely something to check out!</p>

<h3 id="embedded-hal">embedded-hal</h3>

<p>Finally, we come to the <code>embedded-hal</code> crate which defines a number of <em>traits</em> that are consistent across various MCUs. These traits are then implemented for specific MCUs, such as the <code>stm32f30x-hal</code> crate. The goal of these traits and crates is to allow code to be written which is MCU independent, and allow that code to be easily shared. For instance, write a driver for the BLE module once and be able to use it on <em>any</em> MCU which has a <code>-hal</code> crate. This is a admirable goal, and will hopefully make embedded development in Rust significantly less fragmented than it is in C or C++.</p>

<p>Currently, however, the traits defined in the <code>embedded-hal</code> are not stable and the implementation details of various MCU <code>-hal</code> crates is most likely in flux. This will potentially lead to a number of headaches down the road as things change, but I think it is important to contribute to this effort.</p>

<p>One of the interesting things I ran into when working with the <code>stm32f30x-hal</code> is that it is no longer possible to go down to the level of the <code>svd2rust</code>-generated crates from the board-support firmware. Once the <code>-hal</code> crate is brought in, it is expected that <em>all</em> register access is done via that crate. This is slightly frustrating because the <code>stm32f30x-hal</code> crate is not close to being fully featured. However, this is easily fixed by forking the <code>-hal</code> crate and adding functionality where I need it. This makes sense, because people are more likely to upstream additions to the <code>-hal</code> crates if they are forced to fork the crate, but it is slightly annoying since the structure of the <code>-hal</code> crate <em>might</em> change dramatically by next week.</p>

<h2 id="prusto-watch-firmware">Prusto Watch Firmware</h2>

<p>Given the current state of embedded Rust, there are a few different possibilities for how to write firmware for the Prusto Watch. For instance, I could rely on RTFM + the library provided by <code>svd2rust</code> and get very far. However, since a large goal of this project is to hopefully contribute back to the community, the best way to do that is to dive in head-first with the <code>embedded-hal</code> traits and specifically the <code>stm32f30x-hal</code> crate. I plan on adding all of the functionality I need to my fork of the <code>stm32f30x-hal</code> crate, and ideally get them merged upstream.</p>

<p>Currently the Prusto Watch firmware does basically nothing. My primary goal so far was to ensure that I <em>could</em> operate various peripherals rather than getting them fully functional. Below is a list of things I have working so far:</p>

<ul>
<li>Blinking an LED using an interrupt driven by a timer.</li>
<li>Verified that UART can transmit, although getting errors when trying to receive from the BLE module.</li>
<li>In theory SPI is working, although it I have not been able to get probes to verify that data is being transmitted.</li>
</ul>

<p>This is obviously not much, but I believe I have a good understanding of the various libraries and tools such that I can meaningfully make progress in the next few weeks.</p>

<h2 id="hardware">Hardware</h2>

<p>One of the biggest issues I had was actually verifying that various peripherals were actually functional. This is because I designed the hardware <em>terribly</em> for a first-pass. Below is the PCB layout that I created:</p>

<p><img src="/images/prusto_watch/prusto_watch_ver1.svg" alt="watch v0.1" /></p>

<p>Although I was able to get the form-factor extremely close to ideal, I did not put in any methods for debugging. Thus, I ended up splicing wires to various pads in order to get probes connected to <em>something</em>. This allowed me to verify that UART was functional, but it was not ideal.</p>

<p>The second iteration of the board will be much, <em>much</em> larger. It will also have many header pins for easy probing of basically every peripheral. If I had done this originally I think I could have made significantly more progress actually getting things BLE or the IMU working.</p>

<p>However, the hardware as is has allowed me to verify a number of things. For instance, I know the MCU is functional, the BLE module is functional, and that the power-multiplexing and LI-charging are working. I also learned that the IMU is extremely difficult to get soldered on correctly, which may mean switching to a new package.</p>

<h2 id="next-steps">Next Steps</h2>

<p>The next steps are to send out a revised board design with a focus on debugability, and to use that new board for actually getting various peripherals functional. I hope to have drivers for the IMU, BLE module, screen, and (hopefully) USB in around three weeks. From there I can focus on writing OS-level functionality and actually making useable smart-watch!</p>


<footer>
    <hr/>
    <div class="footer-inner">
        <p>&copy; Byron Wasti</p>
        <p><a href="mailto:byron.wasti@gmail.com">byron.wasti@gmail.com</a></p>
        <p><a href="https://www.linkedin.com/in/byron-wasti-595b23a4">Linkedin</a></p>
    </div>
</footer>

</body>
</html>

